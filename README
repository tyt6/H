-*- encoding: utf-8-unix -*-

Develop is stopped.

日本語
  中止
  haskell->sexp なparser作ろうと思ったが、indent-ruleだけではsexpにならないことが判明.
  parseModuleは使いこなせないと判断。

  haskell のIO()内をCみたいにeagerに評価して（IO関数の中身を組み換えます）
  
    import GHC.IOArray
    
    io1:: Ix i => IOArray i e -> i -> IOArray i e -> i -> IO Io2out
    io1 arr ix arr2 ix2= io2( iofunc2, ioarr o [ix], ioarr o [ix] <- ioarr2 o [ix2]);
    
  みたい(未定)に書けるようにしたい。(他の言語も混ざているかもしれません)
  (インストール中に書いてるので良い例が思いつかない。Haskellにも慣れていない。)
  
  上記の例は次のように組み換えます。(コンパイルに-XBangPatterns加えます。)
    import GHC.IOArray
  
    io1:: Ix i => IOArray i e -> i -> IOArray i e -> i -> IO Io2out
    io1 arr ix arr2 ix2 = do
      ! _uniquevar1_ <- readIOArray ioarr ix
      ! _uniquevar2_ <- readIOArray ioarr2 ix2
      writeIOArray ioarr ix _uniquevar2_
      ! _uniquevar3_ <- io2 _uniquevar1_ _uniquevar2_
      return _uniquevar3_


型推論を使わない場合
    import GHC.IOArray
    
    io1:: Ix i => IOArray i e -> i -> IOArray i e -> i -> IO Io2out
    io1 arr ix arr2 ix2= iofunc1 (iocall iofunc2) (ioref iovar) (ioaref ioarr i)x (ioaset ioarr ix (ioaref ioarr2 ix2))

    iofunc1 :: iofunc2Return -> iovarReturn -> ioarrReturn -> ioarr2Return ->iofunc1return
      